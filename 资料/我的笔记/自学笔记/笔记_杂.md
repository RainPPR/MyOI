# 笔记

1. 求最大值时，重复不影响结果 $\max(\max(a,b),max(b,c)) = \max(a,b,c)$
2. STL_sort排序自定义结构体时既可以定义compare函数，也可以重载“<”。
```cpp
// 方法一：
struct node
{
    int a, b;
} arr[N];
bool cmp(node a, node b)
{
    return a.a < b.a;
}
sort(a, a + n, cmp);
// 方法二：
struct node
{
    int a, b;
    bool operator < (const node &W) const
    {
        return a < W.a;
    }
} arr[N];
sort(a, a + n);
```
3. C++对数函数：`log()`
* 以 $e$ 为底的对数 $\log_ex$（即自然对数 $\ln x$）：
```cpp
double log (double x);
float log (float x);
long double log (long double x);
double log (T x);  // T为整型
```
* 以 2 为底的对数 $\log_2x$：
```cpp
double log2(double x);
float log2(float x);
long double log2(long double x);
double log2(T x);  // T为整型
```
* 以 10 为底的对数 $\log_{10}x$（即常用对数 $\lg x$）：
```cpp
double log10 (double x);
float log10 (float x);
long double log10 (long double x);
double log10 (T x);  // T为整型
```
* 对数恒等式： $\log_ba = \log_ya \div \log_yb$
所以 C++ 中，$\log_an$ 可写作 `log(n) / log(a)`
```cpp
// 计算 log a(n)
double Log(int n, int a)
{
    return log(n) / log(a);
}
```
4. 后缀表达式运算：遍历后缀表达式 —
   * 【遇到数字：入栈】
   * 【遇到运算符：取出栈顶两个数字，运算后将结果入栈】
   * 最后栈中剩下的即为结果
5. 搜索剪枝技巧
   * 可行性剪枝
   判断继续搜索能否得出答案，如果不能直接回溯。
   * 最优性剪枝，
   记录当前得到的最优值，如果当前路径已经无法产生比当前最优解更优的解时，可以提前回溯。
6. 四舍五入
```cpp
float num=0;
cin >> num;
num=(int)((num+0.05)*10)/10.0;
printf("%.1f",num);
```
7. 在 C++ 中：
int 溢出是 Undefined Behavior，是否取会模取决于编译器。
unsigned int 溢出是 Define Behavior，在溢出时自动取模。
8. 系统为某一程序分配空间时
所需时间与空间大小无关，与申请次数有关
9. 关于字符串按格式输入（判断格式是否正确）的题：
```cpp
// 以CSP-J2021第三题（网络连接）为例
bool check(string s)     // 判断格式是否为：a.b.c.d:e；0 < a,b,c,d < 256；0 < e < 65536；无前导零
{
	long long a, b, c, d, port;
	if (sscanf(s.c_str(), "%lld.%lld.%lld.%lld:%lld", &a, &b, &c, &d, &port) != 5)
		return false;     // 字符串格式化，如果输入的数不是五个，返回False
	if ((a < 0) || (a > 255) || (b < 0) || (b > 255) || (c < 0) || (c > 255) || (d < 0) || (d > 255) || (port < 0) || (port > 65535))
		return false;     // 数字超过范围，返回False
	stringstream ss;      // 按格式重新生成
	ss << a << '.' << b << '.' << c << '.' << d << ':' << port;
	return ss.str() == s; // 判断是否有前导零
}
```
10. 对于取模式子 $m \bmod n = p$ 来说
   * 假设 $m > n$，那么 $0 \le p <n$
   * 假设 $m=n$，那么 $p=0$
   * 假设 $m<n$，那么 $p=m$
所以 $p\le min(m,n)$
11. 对于方程组
$$\left\{\begin{matrix} 
    x + y = \dots & ①\\  
    x \times y = \dots & ②
\end{matrix}\right.
$$
可以将 $②$ 转化为 $x - y = \dots$ 解。$x - y$ 同理。