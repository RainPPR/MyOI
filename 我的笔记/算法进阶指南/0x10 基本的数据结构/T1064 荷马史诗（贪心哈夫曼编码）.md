# T1064 荷马史诗

## 题目描述

Allison 最近迷上了文学。她喜欢在一个慵懒的午后，细细地品上一杯卡布奇诺，静静地阅读她爱不释手的《荷马史诗》。但是由《奥德赛》和《伊利亚特》 组成的鸿篇巨制《荷马史诗》实在是太长了，Allison 想通过一种编码方式使得它变得短一些。

一部《荷马史诗》中有 $n$ 种不同的单词，从 $1$ 到 $n$ 进行编号。其中第 $i$ 种单词出现的总次数为 $w_i$。Allison 想要用 $k$ 进制串 $s_i$ 来替换第 $i$ 种单词，使得其满足如下要求：

对于任意的 $1\leq i, j\leq n$ ，$i\ne j$ ，都有：$s_i$ 不是 $s_j$ 的前缀。

现在 Allison 想要知道，如何选择 $s_i$，才能使替换以后得到的新的《荷马史诗》长度最小。在确保总长度最小的情况下，Allison 还想知道最长的 $s_i$ 的最短长度是多少？

一个字符串被称为 $k$ 进制字符串，当且仅当它的每个字符是 $0$ 到 $k-1$ 之间（包括 $0$ 和 $k-1$ ）的整数。

字符串 $str1$ 被称为字符串 $str2$ 的前缀，当且仅当：存在 $1 \leq t\leq m$ ，使得 $str1 = str2[1..t]$。其中，$m$ 是字符串 $str2$ 的长度，$str2[1..t]$ 表示 $str2$ 的前 $t$ 个字符组成的字符串。

## 输入格式

输入的第 $1$ 行包含 $2$ 个正整数 $n, k$ ，中间用单个空格隔开，表示共有 $n$ 种单词，需要使用 $k$ 进制字符串进行替换。

接下来 $n$ 行，第 $i + 1$ 行包含 $1$ 个非负整数 $w_i$，表示第 $i$ 种单词的出现次数。

## 输出格式

输出包括 $2$ 行。

第 $1$ 行输出 $1$ 个整数，为《荷马史诗》经过重新编码以后的最短长度。

第 $2$ 行输出 $1$ 个整数，为保证最短总长度的情况下，最长字符串 $s_i$ 的最短长度。

## 样例 #1

### 样例输入 #1

```
4 2
1
1
2
2
```

### 样例输出 #1

```
12
2
```

## 样例 #2

### 样例输入 #2

```
6 3
1
1
3
3
9
9
```

### 样例输出 #2

```
36
3
```

## 提示

#### 【样例解释】

#### 样例 1 解释

用 $X(k)$ 表示 $X$ 是以 $k$ 进制表示的字符串。

一种最优方案：令 $00(2)$ 替换第 $1$ 种单词， $01(2)$ 替换第 2 种单词， $10(2)$ 替换第 $3$ 种单词，$11(2)$ 替换第 $4$ 种单词。在这种方案下，编码以后的最短长度为：

$1 × 2 + 1 × 2 + 2 × 2 + 2 × 2 = 12$

最长字符串 $s_i$ 的长度为 $2$ 。

一种非最优方案：令 $000(2)$ 替换第 $1$ 种单词，$001(2)$ 替换第 $2$ 种单词，$01(2)$ 替换第 $3$ 种单词，$1(2)$ 替换第 $4$ 种单词。在这种方案下，编码以后的最短长度为：

$1 × 3 + 1 × 3 + 2 × 2 + 2 × 1 = 12$

最长字符串 $s_i$ 的长度为 $3$ 。与最优方案相比，文章的长度相同，但是最长字符串的长度更长一些。

#### 样例 2 解释

一种最优方案：令 $000(3)$ 替换第 $1$ 种单词，$001(3)$ 替换第 $2$ 种单词，$01(3)$ 替换第 $3$ 种单词， $02(3)$ 替换第 $4$ 种单词， $1(3)$ 替换第 5 种单词， $2(3)$ 替换第 $6$ 种单词。

#### 【数据规模与约定】

所有测试数据的范围和特点如下表所示（所有数据均满足 $0 < w_i \leq 10^{11}$）：

| 测试点编号 |  $n$ 的规模  | $k$ 的规模 |            备注            |
| :--------: | :----------: | :--------: | :------------------------: |
|    $1$     |    $n=3$     |   $k=2$    |                            |
|    $2$     |    $n=5$     |   $k=2$    |                            |
|    $3$     |    $n=16$    |   $k=2$    |     所有 $w_i$ 均相等      |
|    $4$     |  $n=1\,000$  |   $k=2$    | $w_i$ 在取值范围内均匀随机 |
|    $5$     |  $n=1\,000$  |   $k=2$    |                            |
|    $6$     | $n=100\,000$ |   $k=2$    |                            |
|    $7$     | $n=100\,000$ |   $k=2$    |     所有 $w_i$ 均相等      |
|    $8$     | $n=100\,000$ |   $k=2$    |                            |
|    $9$     |    $n=7$     |   $k=3$    |                            |
|    $10$    |    $n=16$    |   $k=3$    |     所有 $w_i$ 均相等      |
|    $11$    |  $n=1\,001$  |   $k=3$    |     所有 $w_i$ 均相等      |
|    $12$    | $n=99\,999$  |   $k=4$    |     所有 $w_i$ 均相等      |
|    $13$    | $n=100\,000$ |   $k=4$    |                            |
|    $14$    | $n=100\,000$ |   $k=4$    |                            |
|    $15$    |  $n=1\,000$  |   $k=5$    |                            |
|    $16$    | $n=100\,000$ |   $k=7$    | $w_i$ 在取值范围内均匀随机 |
|    $17$    | $n=100\,000$ |   $k=7$    |                            |
|    $18$    | $n=100\,000$ |   $k=8$    | $w_i$ 在取值范围内均匀随机 |
|    $19$    | $n=100\,000$ |   $k=9$    |                            |
|    $20$    | $n=100\,000$ |   $k=9$    |                            |

#### 【提示】

选手请注意使用 64 位整数进行输入输出、存储和计算。

#### 【评分方式】

对于每个测试点：

- 若输出文件的第 $1$ 行正确，得到该测试点 $40\%$ 的分数；
- 若输出文件完全正确，得到该测试点 $100\%$ 的分数。

## 题解

哈夫曼编码版字体。（你说得对，但是我打错字了

## 概念

一棵包含有 $n$ 个叶子节点的 $k$ 叉树，其中第 $i$ 个叶子节点带有权值 $W_i$。

**树的带权路径长度**，定义为从根结点到各叶结点的路径长度与相应叶节点权值的乘积之和。

树的带权路径长度，记为 WPL（Weighted Path Length of Tree），公式表示：

$$
\text{WPL}=\sum_{i=1}^nW_iL_i
$$

在一组有确定权值的叶子节点中，可以构造出不同的 $k$ 叉树。

其中，WPL 最小的 $k$ 叉树，称为 $k$ 叉**哈夫曼树**（Huffman 树）。

## 哈夫曼算法

容易发现，对于哈夫曼树，权值越小离根越远，反之，权值越大深度越小。

因此，容易得出，仅有叶子节点的度为 $0$，其他节点的度均为 $k$。

证明：如果其他节点的度小于 $k$，那么意味着下面的节点放到这个空位，结果更优。

因此，我们需要额外添加一些权值为 $0$ 的叶子节点，使得叶子节点个数 $n$ 满足，

$$
n-1\equiv0\pmod{k-1}
$$

这样，我们就可以保证空的位置，会放在叶子上而不是非叶子节点，使得贪心正确。

## 算法流程

+ 初始化：将给定的 $n$ 个叶子节点，直接连到根上，共 $n+1$ 个节点。
+ 合并：从二叉树中选取两个权值和最小的节点，合并为一个新的节点。
+ 重复合并操作，直至只剩 $k-1$ 个节点，所得二叉树即为哈夫曼树。

![](https://oi-wiki.org/ds/images/huffman-tree-2.png)

如果需要所得的最长编码最短，则还需要优先合并当前层数少的节点。

## 模板题

链接：[P2168 [NOI2015] 荷马史诗](https://www.luogu.com.cn/problem/P2168)。

模板题，模拟即可，

```cpp
#include <bits/stdc++.h>

using namespace std;

constexpr int N = 1e5 + 10;

using ll = long long;

struct emm {
	ll w; int h;
	emm() = default;
	emm(ll w, int h): w(w), h(h) {}
	friend bool operator <(const emm &a, const emm &b) {
		return a.w == b.w ? a.h > b.h : a.w > b.w;
	}
};

signed main() {
	ios::sync_with_stdio(false);
	cin.tie(nullptr), cout.tie(nullptr);
	int n, k; cin >> n >> k; priority_queue<emm> heap;
	ll w; for (int i = 1; i <= n; ++i) cin >> w, heap.emplace(w, 1);
	while ((heap.size() - 1) % (k - 1) != 0) heap.emplace(0, 1);
	ll ans = 0; auto merge = [&] {
		int h = 0; ll w = 0;
		for (int i = 1; i <= k; ++i) h = max(h, heap.top().h), w += heap.top().w, heap.pop();
		ans += w, heap.emplace(w, h + 1);
	};
	while (heap.size() >= k) merge();
	cout << ans << endl << heap.top().h - 1 << endl;
	return 0;
}
```

## 简单题

链接：[P1090 [NOIP2004 提高组] 合并果子](https://www.luogu.com.cn/problem/P1090)。

容易发现，合并顺序即叶子节点的深度，于是哈夫曼编码。

权值小的节点优先合并即可，代码：

```cpp
#include <bits/stdc++.h>

using namespace std;

signed main() {
    ios::sync_with_stdio(false);
    cin.tie(nullptr), cout.tie(nullptr);
    int n; cin >> n;
    priority_queue<int, vector<int>, greater<int>> d;
    for (int i = 0, x; i < n; ++i) cin >> x, d.push(x);
    int ans = 0;
    while (d.size() > 1) {
    	int a = d.top(); d.pop();
    	int b = d.top(); d.pop();
    	ans += a + b, d.push(a + b);
    }
    cout << ans << endl;
	return 0;
}
```