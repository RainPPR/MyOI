# T1049 双端队列

## 题目描述

Sherry 现在碰到了一个棘手的问题，有 $N(1 \le N \le 200000)$ 个整数需要排序。

Sherry 手头能用的工具就是若干个双端队列。

她从 $1$ 到 $N$ 需要依次处理这 $N$ 个数，对于每个数，Sherry 能做以下两件事：

1．新建一个双端队列，并将当前数作为这个队列中的唯一的数；

2．将当前数放入已有的队列的头之前或者尾之后。

对所有的数处理完成之后，Sherry 将这些队列按一定的顺序连接起来后就可以得到一个非降的序列。

请你求出最少需要多少个双端序列。

## 输入格式

第一行输入整数 $N$，代表整数的个数。

接下来 $N$ 行，每行包括一个整数 $D_i$，代表所需处理的整数。

## 输出格式

输出一个整数，代表最少需要的双端队列数。

## 样例 #1

### 样例输入 #1

```
6
3
6
0
9
6
3
```

### 样例输出 #1

```
2
```

## 题解

注意到，最后的双端队列只能按照一个顺序拼接，因此：

+ 最终的双端队列中的数，一定是单调递增的。
+ 最终的若干个双端队列，按照一定的顺序，一定是首位相接单调递增的。

我们考虑，这几个双端队列有什么性质。

注意到，我们把排序后的数组，分成若干段，这每一段：

+ 元素在原数组中的下标（用 $\mathit{id}$ 表示）一定是，先下降再上升的谷形。

那么，这个每一个谷，都可以用一个双端队列存储，问题转化为，

将排序好的数列，分为若干段，最小化段数，使得每一段的 $\mathit{id}$ 为谷形。

但是，注意到原数组中可能存在相同的数字，考虑如何处理，容易得出：

+ 原数组中，相同的数字，下标单调的存放，一定不劣。

因为，一次由上升转为下降，就需要多一段，这是我们不希望的。

于是，我们分类讨论，

+ 如果现在处于下降趋势，
  + 如果当前段加入后，能维持下降，那么加入；
  + 否则，将趋势转为上升，然后加入。
+ 如果现在处于上升趋势，
  + 如果当前段加入后，能维持上升，那么加入；
  + 否则，将趋势转为下降，加入后答案加一。

这里考虑到，如果不按照这个趋势来，那么后面的区间再加入，此时答案一定更大，

而后面的区间不会影响到其再后面的答案，因此贪心正确。

代码：

```cpp
#include <bits/stdc++.h>

using namespace std;

#define endl '\n'
#define range(x) (x).begin(), (x).end()

struct emm {
    int v, id;
    friend bool operator <(const emm &a, const emm &b) {
        return a.v == b.v ? a.id < b.id : a.v < b.v;
    }
};

signed main() {
    ios::sync_with_stdio(false);
    cin.tie(nullptr), cout.tie(nullptr);
    int n; cin >> n; vector<emm> a(n);
    for (int i = 0; i < n; ++i) a[i].id = i + 1, cin >> a[i].v;
    sort(range(a));
    int cnt = 1, mx = 1e19, dir = -1;
    for (int l = 0, r = 0; l < n; l = r) {
        while (r < n && a[l].v == a[r].v) ++r;
        int u = a[l].id, v = a[r - 1].id;
        if (dir == -1) {
            if (v < mx) mx = u;
            else mx = v, dir = 1;
        }
        else if (dir == 1) {
            if (u > mx) mx = v;
            else mx = u, dir = -1, ++cnt;
        }
    }
    cout << cnt << endl;
    return 0;
}
```

这里面用到了经典的将区间分为值相同的若干段的方法。