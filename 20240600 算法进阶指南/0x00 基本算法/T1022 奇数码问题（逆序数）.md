# T1022 奇数码问题

## 题目描述

你一定玩过八数码游戏，它实际上是在一个 $3 \times 3$ 的网格中进行的，$1$ 个空格和 $1 \sim 8$ 这 $8$ 个数字恰好不重不漏地分布在这 $3 \times 3$ 的网格中。

例如：

    5 2 8
    1 3 _
    4 6 7


在游戏过程中，可以把空格与其上、下、左、右四个方向之一的数字交换（如果存在）。

例如在上例中，空格可与左、上、下面的数字交换，分别变成：

    5 2 8       5 2 _      5 2 8
    1 _ 3       1 3 8      1 3 7
    4 6 7       4 6 7      4 6 _


奇数码游戏是它的一个扩展，在一个 $n \times n$ 的网格中进行，其中 $n$ 为奇数，$1$ 个空格和 $1 \sim n^2-1$ 这 $n^2-1$ 个数恰好不重不漏地分布在 $n \times n$ 的网格中。

空格移动的规则与八数码游戏相同，实际上，八数码就是一个 $n=3$ 的奇数码游戏。

现在给定两个奇数码游戏的局面，请判断是否存在一种移动空格的方式，使得其中一个局面可以变化到另一个局面。

## 输入格式

多组数据，对于每组数据：

第 $1$ 行输入一个整数 $n$，$n$ 为奇数。

接下来 $n$ 行每行 $n$ 个整数，表示第一个局面。

再接下来 $n$ 行每行 $n$ 个整数，表示第二个局面。

局面中每个整数都是 $0 \sim n^2-1$ 之一，其中用 $0$ 代表空格，其余数值与奇数码游戏中的意义相同，保证这些整数的分布不重不漏。

## 输出格式

对于每组数据，若两个局面可达，输出 `TAK`，否则输出 `NIE`。

## 样例 #1

### 样例输入 #1

```
3
1 2 3
0 4 6
7 5 8
1 2 3
4 5 6
7 8 0
1
0
0
```

### 样例输出 #1

```
TAK
TAK
```

## 提示

$1 \le n < 500$

## 题解

前置知识：逆序数（[https://oi-wiki.org/math/permutation/#逆序和逆序数](https://oi-wiki.org/math/permutation/#%E9%80%86%E5%BA%8F%E5%92%8C%E9%80%86%E5%BA%8F%E6%95%B0)）。

考虑奇数码中，交换的过程中对整体的排列造成了什么影响。

所说整体的排列，是不考虑空位的情况下，从上到下、从左到右的读，记下排列。

+ 如果是左右交换，显然，排列没有任何变化。
+ 如果是上下交换，相当于某一个数跨了 $n-1$ 位去插入。

考虑下面一个操作会对这个排列造成什么影响。啊对，逆序数。

这里面原先的逆序对会变成顺序对，顺序对会变成逆序对。

因为是隔着偶数个交换的，因此顺序对和逆序对个数一定程度上增减抵消。

此处的一定程度上，表示的是逆序数的奇偶性。也就是排列的奇偶性。

+ 此时我们得出，若两个排列奇偶性不同，那么他们一定不可达到。
+ 已经证明了必要性，但是没有证明充分性：如果逆序数相同，则一定可以达到。

证明：书上也没写，先咕一下（（（

即一定可以通过若干种交换，去达到任何一种不改变奇偶性的排列。

证毕。因为这里逆序数不用离散化，显然用树状数组比较好（其实是我不会归并），

```cpp
#include <bits/stdc++.h>

using namespace std;

#define lowbit(x) ((x) & -(x))

constexpr int N = 1e6;

int n, s[N];

int query(int x) {
	int r = 0;
	for (; x; x -= lowbit(x))
	r += s[x];
	return r;
}

void add(int x) {
	for (; x <= n; x += lowbit(x))
	++s[x];
}

int rej(vector<int> &x) {
	for (int i = 1; i <= n; ++i) s[i] = 0;
	int ans = 0, m = x.size();
	for (int i = m - 1; ~i; --i) ans = (ans + query(x[i])) & 1, add(x[i]);
	return ans;
}

signed main() {
    ios::sync_with_stdio(false);
    cin.tie(nullptr), cout.tie(nullptr);
    while (cin >> n) {
    	n = n * n; vector<int> a, b;
    	for (int i = 0, x; i < n; ++i) cin >> x, x ? a.push_back(x) : void(0);
    	for (int i = 0, x; i < n; ++i) cin >> x, x ? b.push_back(x) : void(0);
    	int n = rej(a), m = rej(b);
    	puts(n == m ? "TAK" : "NIE");
    } return 0;
}
```