# T1008 费解的开关

# 费解的开关

## 题目描述

你玩过“拉灯”游戏吗？

$25$ 盏灯排成一个 $5 \times 5$ 的方形。

每一个灯都有一个开关，游戏者可以改变它的状态。

每一步，游戏者可以改变某一个灯的状态。

游戏者改变一个灯的状态会产生连锁反应：和这个灯上下左右相邻的灯也要相应地改变其状态。

我们用数字 $1$ 表示一盏开着的灯，用数字 $0$ 表示关着的灯。

下面这种状态

    10111
    01101
    10111
    10000
    11011


在改变了最左上角的灯的状态后将变成：

    01111
    11101
    10111
    10000
    11011


再改变它正中间的灯后状态将变成：

    01111
    11001
    11001
    10100
    11011


给定一些游戏的初始状态，编写程序判断游戏者是否可能在 $6$ 步以内使所有的灯都变亮。

## 输入格式

第一行输入正整数 $n$，代表数据中共有 $n$ 个待解决的游戏初始状态。

以下若干行数据分为 $n$ 组，每组数据有 $5$ 行，每行 $5$ 个字符。

每组数据描述了一个游戏的初始状态。

各组数据间用一个空行分隔。

## 输出格式

一共输出 $n$ 行数据，每行有一个小于等于 $6$ 的整数，它表示对于输入数据中对应的游戏状态最少需要几步才能使所有灯变亮。

对于某一个游戏初始状态，若 $6$ 步以内无法使所有灯变亮，则输出 `-1`。

## 样例 #1

### 样例输入 #1

```
3
00111
01011
10001
11010
11100

11101
11101
11110
11111
11111

01111
11111
11111
11111
11111
```

### 样例输出 #1

```
3
2
-1
```

## 提示

测试数据满足 $0 < n \le 500$。

## 题解

分享一个在做 POJ1681 Painter's Problem 时，看到过的一个题解的方法。

注意到当进行一个操作的时候，只会对其上方一行的一个值造成影响。

因此考虑枚举第一行每个位置是否操作，然后顺下去。

即下面的每一行都去判断这个需不需要操作，以保证上一行全部打开。

对于最后一行，我们进行操作完后，没有去保证它的了，因此这一行决定了一个枚举是否可行。

具体细节看代码：

```cpp
#include <bits/stdc++.h>

using namespace std;

char gc() {
	char c = getchar();
	while (!isdigit(c)) c = getchar();
	return c;
}

int a[10][10], b[10][10];

void ps(int i, int j) {
	b[i][j] ^= 1;
	b[i - 1][j] ^= 1, b[i + 1][j] ^= 1;
	b[i][j - 1] ^= 1, b[i][j + 1] ^= 1;
}

int solev() {
	int ans = 7;
	for (int i = 1; i <= 5; ++i)
		for (int j = 1; j <= 5; ++j)
			a[i][j] = gc() - '0';
	for (int e = 0; e < (1 << 5); ++e) {
		for (int i = 1; i <= 5; ++i)
			for (int j = 1; j <= 5; ++j)
				b[i][j] = a[i][j];
		int cnt = 0;
		for (int i = 1; i <= 5; ++i)
			if (e & (1 << i - 1)) ps(1, i), ++cnt;
		for (int i = 2; i <= 5; ++i)
			for (int j = 1; j <= 5; ++j)
				if (!b[i - 1][j]) ps(i, j), ++cnt;
		int ok = 1;
		for (int i = 1; i <= 5; ++i)
			if (!b[5][i]) ok = 0;
		if (ok) ans = min(ans, cnt);
	} return ans > 6 ? -1 : ans;
}

signed main() {
	// ios::sync_with_stdio(false);
	// cin.tie(nullptr), cout.tie(nullptr);
	int T; cin >> T;
	while (T--) cout << solev() << endl;
	return 0;
}
```

时间复杂度：$\mathcal O(T2^nn^2)$。

在这道题里面，$T$ 就是输入的 $n$（数据组数），$n$ 就是方块大小 $5$ 哦。