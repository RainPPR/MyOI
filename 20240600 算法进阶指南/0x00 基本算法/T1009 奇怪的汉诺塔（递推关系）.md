# T1009 奇怪的汉诺塔

## 题目描述

汉诺塔问题，条件如下：

1、这里有A、B、C和D四座塔。

2、这里有n个圆盘，n的数量是恒定的。

3、每个圆盘的尺寸都不相同。

4、所有的圆盘在开始时都堆叠在塔A上，且圆盘尺寸从塔顶到塔底逐渐增大。

5、我们需要将所有的圆盘都从塔A转移到塔D上。

6、每次可以移动一个圆盘，当塔为空塔或者塔顶圆盘尺寸大于被移动圆盘时，可将圆盘移至这座塔上。

请你求出将所有圆盘从塔A移动到塔D，所需的最小移动次数是多少。

## 输入格式

没有输入

## 输出格式

对于每一个整数n(1≤*n*≤12),输出一个满足条件的最小移动次数，每个结果占一行。

## 题解

先考虑最基础的汉诺塔问题，然后再考虑这道题。

---

有 $n$ 个盘子，$3$ 个柱子（此处省略若干个字

考虑一共有哪些情况。

容易发现，只能先把 $n$ 个盘子中的 $n-1$ 个移到下一个，然后把最大的移到最后一个，然后再把那 $n-1$ 个从第二个移到第三个。

表示为：

$$
\begin{aligned}
F_1&=1\\
F_n&=2F_{n-1}+1
\end{aligned}
$$

然后是证明，

- 证明存在性，容易发现上面的公式就是一个构造性的证明。
- 证明数值正确，

假设我们的推论不正确，则有另一关系 $G_n$ 为正确的关系，

我们尝试通过证明 $F_n\ge G_n$ 且 $F_n\le G_n$ 来说明 $F_n=G_n$。

- $F_n\ge G_n$：我们构造的是一个可行解，因为 $G_n$ 是最优解，因此这条显然成立。
- $F_n\le G_n$：如果第一步不是把 $n-1$ 个移走，而是任意移走 $n-2$ 或更少，那么，为了把最大的盘子移到最后一个柱子上，我们显然需要把这个柱子清空，即至少需要进行 $2F_{n-1}$ 个操作来实现，于是有 $F_n\le G_n$。

然后考虑求解封闭形式。

这个东西在《具体数学》里面有非常详细的解释，这里说一个其中比较启发式的做法。

有，

$$
\begin{aligned}
F_n&=2F_{n-1}+1\\
F_n+1&=2F_{n-1}+2
\end{aligned}
$$

记 $G_n=F_n+1$，则

$$
G_n=2G_{n-1}
$$

这个就很简单，有，

$$
G_n=2^n
$$

于是就有，

$$
F_n=G_n-1=2^n-1
$$

即，经典的汉诺塔封闭形式。

---

然后考虑四个柱子的情况。

每次会有几种可能性呢？显然不止一种了。

因为我们把任意 $x<a$ 个盘子移动以后，不像三个柱子的那样会无路可走。

剩下的一个柱子让我们有足够的空间在其进行一个三个柱子的汉诺塔变换。

我们设四个柱子的为 $G_n$，则

$$
G_n=\min_{1\le i<n}\{2G_i+F_{n-i}\}
$$

也比较好理解，和上面一样，把 $i$ 个盘子移动，然后把剩下的移到最后一个，再把那 $i$ 个也移到最后一个。

这个东西不好找封闭形式，递推即可。

---

对于实现，我们可以进行一个等价变换，

$$
\begin{aligned}
G_n&=\min_{1\le i<n}\{2G_i+F_{n-i}\}\\
&=\min_{1\le(n-i)<n}\{2G_{n-i}+F_{n-(n-i)}\}\\
&=\min_{1\le i<n}\{2G_{n-i}+F_i\}\\
&=\min_{1\le i<n}\{2G_{n-i}+2^i-1\}\\
\end{aligned}
$$

然后就是代码了。

这道题的输入输出格式有点坑人，意思就是让你输出 $12$ 行，第 $i$ 行是 $G_i$ 的。

```cpp
#include <bits/stdc++.h>

using namespace std;

constexpr int N = 25;

int g[N];

signed main() {
	ios::sync_with_stdio(false);
	cin.tie(nullptr), cout.tie(nullptr);
	memset(g, 0x3f, sizeof g); g[1] = 1;
	for (int i = 2; i <= 12; ++i) for (int j = 1; j < i; ++j)
		g[i] = min(g[i], 2 * g[i - j] + (1 << j) - 1);
	for (int i = 1; i <= 12; ++i) cout << g[i] << endl;
	return 0;
}
```