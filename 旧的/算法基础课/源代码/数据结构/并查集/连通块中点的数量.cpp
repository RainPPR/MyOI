#include<cstdio>
#include<iostream>

using namespace std;

const int N = 1e5 + 10;

int n, m;
int p[N], sz[N];

// 返回 x 所在集合的编号（祖宗结点）
int find(int x)
{
	if (p[x] != x)
		p[x] = find(p[x]);
	return p[x];
}

int main()
{
	scanf("%d %d", &n, &m);

	// 初始化，假定节点编号是 1 ~ n
	for (int i = 1 ; i <= n ; ++i)
		p[i] = i, sz[i] = 1;

	while (m--)
	{
		char op[3];
		int a, b;
		scanf("%s", op);
		// 合并 a 和 b 所在的两个集合
		if (op[0] == 'C')
		{
			scanf("%d %d", &a, &b);
			int fa = find(a), fb = find(b);
			if (fa != fb)   // a 和 b 可能相等
				sz[fb] += sz[fa], p[fa] = fb;
		}
		// 询问点 a 和点 b 是否在同一个连通块中
		else if (op[1] == '1')
		{
			scanf("%d %d", &a, &b);
			if (find(a) == find(b))
				printf("Yes\n");
			else
				printf("No\n");
		}
		// 询问点 a 所在连通块中点的数量
		else
		{
			scanf("%d", &a);
			printf("%d\n", sz[find(a)]);
		}
	}
	return 0;
}
