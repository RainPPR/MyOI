# 学而思复赛总结
## $T_2$ 专项突破
#### 1. 减少排序次数
#### 2. 缩小排序范围
#### 3. 不满足条件的数据先排除
#### 4. 多个判断条件或表格的，用二维数组代替多个 `if` 语句
#### 5. 数小、量大的排序用桶排
#### 6. 桶排序，负数，加一个增量，变为正数下标
#### 7. 只要不是特别大的数组，能开 `long long` 的都开 `long long`
#### 8. 做题前先看数据范围
#### 9. 循环求最大值，提前声明尽可能小（$-1e9$）
#### 10. 循环求最小值，提前声明尽可能大（$1e9$）
#### 11. 复杂的题分类讨论
#### 12. 枚举 $x$ 的倍数，循环增量是 $x$
#### 13. 与、或连接多个条件的，把最浪费时间的条件放在最后
#### 14. 有条件的，先假定条件成立，再推导，不成立的舍去
#### 15. 数据量超过 $10^6$ 的输入用 `scanf`，否则会超时；数据量小的可以用 `cin`
#### 16. 数据量超过 $10^5$ 的输入用 `printf`，否则会超时；数据量小的可以用 `cout`
#### 17. 难的模拟，可以用 DFS+剪枝
#### 18. 路径可行性计算有重复的，用铅（前）坠（缀）河（和）优化，避免重复遍历。
#### 19. 不同情况，分类讨论
#### 20. 贪心思想，先进行对结果影响大的操作，后进行对结果影响小的操作
## $T_3/T_4$ 部分分
#### 1. 先过一遍题，心里有数再开始做题
#### 2. 难题先做简单算法（搜索等）拿到保底分，再优化、写高级算法（贪心、动态规划等），简单算法还可以用来做对拍
#### 3. 复杂的题，可以用搜索解决小部分测试点
#### 4. `next_permutation`、`prev_permutation` 生成全排列（字典序）
#### 5. 配对问题：固定一个队，对另一个队进行全排列
#### 6. $map<key, value>$ 默认以 $(key, value)$ 键值排序
#### 7. $map$ 下标可以为负，数据量超大也可以（可当做数组用）
#### 8. 判断 $map$ 中是否有 $key$：`map.count(key) != 0`
#### 9. map []访问一个不存在的数据，会自动建一个值为0的数据  
#### 10. map 用 `.lower_bound(key)` 返回第一个大于等于 $key$ 的迭代器（iterator）；用 `.upper_bound(key)` 返回第一个大于 $key$ 的迭代器。
#### 10. 前缀和优化
#### 11. 用除法的时候注意观察除数是否为 $0$
#### 12. 几个数中有 $0$，用 $积=0$ 判断
#### 13. 区间内所有数加上 $x$，用差分
#### 14. 求 $sum\{a_i,a_{i+1},a_{i+2},\dots,a_k\}$ 用前缀和优化
#### 15. 分类：对数据范围要求不同（有特殊条件的）写不同的代码